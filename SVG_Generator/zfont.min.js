/*!
 * Zfont v1.2.8
 * Text plugin for Zdog
 * 2019 James Daniel
 * MIT Licensed 
 * github.com/jaames/zfont
 */
! function (r, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (r = r || self).Zfont = t()
}(this, function () {
    "use strict";
    var z = {
        parse: function (r) {
            var t = z._bin,
                e = new Uint8Array(r),
                a = 0,
                n = (t.readFixed(e, a), t.readUshort(e, a += 4));
            t.readUshort(e, a += 2), t.readUshort(e, a += 2), t.readUshort(e, a += 2);
            a += 2;
            for (var o = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], i = {
                    _data: e
                }, s = {}, h = 0; h < n; h++) {
                var f = t.readASCII(e, a, 4);
                a += 4;
                t.readUint(e, a);
                a += 4;
                var l = t.readUint(e, a);
                a += 4;
                var u = t.readUint(e, a);
                a += 4, s[f] = {
                    offset: l,
                    length: u
                }
            }
            for (h = 0; h < o.length; h++) {
                var d = o[h];
                s[d] && (i[d.trim()] = z[d.trim()].parse(e, s[d].offset, s[d].length, i))
            }
            return i
        },
        _tabOffset: function (r, t) {
            for (var e = z._bin, a = e.readUshort(r, 4), n = 12, o = 0; o < a; o++) {
                var i = e.readASCII(r, n, 4);
                n += 4;
                e.readUint(r, n);
                n += 4;
                var s = e.readUint(r, n);
                n += 4;
                e.readUint(r, n);
                if (n += 4, i == t) return s
            }
            return 0
        }
    };
    z._bin = {
        readFixed: function (r, t) {
            return (r[t] << 8 | r[t + 1]) + (r[t + 2] << 8 | r[t + 3]) / 65540
        },
        readF2dot14: function (r, t) {
            return z._bin.readShort(r, t) / 16384
        },
        readInt: function (r, t) {
            var e = z._bin.t.uint8;
            return e[0] = r[t + 3], e[1] = r[t + 2], e[2] = r[t + 1], e[3] = r[t], z._bin.t.int32[0]
        },
        readInt8: function (r, t) {
            return z._bin.t.uint8[0] = r[t], z._bin.t.int8[0]
        },
        readShort: function (r, t) {
            var e = z._bin.t.uint8;
            return e[1] = r[t], e[0] = r[t + 1], z._bin.t.int16[0]
        },
        readUshort: function (r, t) {
            return r[t] << 8 | r[t + 1]
        },
        readUshorts: function (r, t, e) {
            for (var a = [], n = 0; n < e; n++) a.push(z._bin.readUshort(r, t + 2 * n));
            return a
        },
        readUint: function (r, t) {
            var e = z._bin.t.uint8;
            return e[3] = r[t], e[2] = r[t + 1], e[1] = r[t + 2], e[0] = r[t + 3], z._bin.t.uint32[0]
        },
        readUint64: function (r, t) {
            return 4294967296 * z._bin.readUint(r, t) + z._bin.readUint(r, t + 4)
        },
        readASCII: function (r, t, e) {
            for (var a = "", n = 0; n < e; n++) a += String.fromCharCode(r[t + n]);
            return a
        },
        readUnicode: function (r, t, e) {
            for (var a = "", n = 0; n < e; n++) {
                var o = r[t++] << 8 | r[t++];
                a += String.fromCharCode(o)
            }
            return a
        },
        _tdec: window.TextDecoder ? new window.TextDecoder : null,
        readUTF8: function (r, t, e) {
            var a = z._bin._tdec;
            return a && 0 == t && e == r.length ? a.decode(r) : z._bin.readASCII(r, t, e)
        },
        readBytes: function (r, t, e) {
            for (var a = [], n = 0; n < e; n++) a.push(r[t + n]);
            return a
        },
        readASCIIArray: function (r, t, e) {
            for (var a = [], n = 0; n < e; n++) a.push(String.fromCharCode(r[t + n]));
            return a
        }
    }, z._bin.t = {
        buff: new ArrayBuffer(8)
    }, z._bin.t.int8 = new Int8Array(z._bin.t.buff), z._bin.t.uint8 = new Uint8Array(z._bin.t.buff), z._bin.t.int16 = new Int16Array(z._bin.t.buff), z._bin.t.uint16 = new Uint16Array(z._bin.t.buff), z._bin.t.int32 = new Int32Array(z._bin.t.buff), z._bin.t.uint32 = new Uint32Array(z._bin.t.buff), z._lctf = {}, z._lctf.parse = function (r, t, e, a, n) {
        var o = z._bin,
            i = {},
            s = t,
            h = (o.readFixed(r, t), o.readUshort(r, t += 4)),
            f = o.readUshort(r, t += 2),
            o = o.readUshort(r, t += 2);
        return t += 2, i.scriptList = z._lctf.readScriptList(r, s + h), i.featureList = z._lctf.readFeatureList(r, s + f), i.lookupList = z._lctf.readLookupList(r, s + o, n), i
    }, z._lctf.readLookupList = function (r, t, e) {
        var a = z._bin,
            n = t,
            o = [],
            i = a.readUshort(r, t);
        t += 2;
        for (var s = 0; s < i; s++) {
            var h = a.readUshort(r, t);
            t += 2;
            h = z._lctf.readLookupTable(r, n + h, e);
            o.push(h)
        }
        return o
    }, z._lctf.readLookupTable = function (r, t, e) {
        var a = z._bin,
            n = t,
            o = {
                tabs: []
            };
        o.ltype = a.readUshort(r, t), o.flag = a.readUshort(r, t += 2);
        var i = a.readUshort(r, t += 2);
        t += 2;
        for (var s = 0; s < i; s++) {
            var h = a.readUshort(r, t);
            t += 2;
            h = e(r, o.ltype, n + h);
            o.tabs.push(h)
        }
        return o
    }, z._lctf.numOfOnes = function (r) {
        for (var t = 0, e = 0; e < 32; e++) 0 != (r >>> e & 1) && t++;
        return t
    }, z._lctf.readClassDef = function (r, t) {
        var e = z._bin,
            a = [],
            n = e.readUshort(r, t);
        if (t += 2, 1 == n) {
            var o = e.readUshort(r, t),
                i = e.readUshort(r, t += 2);
            t += 2;
            for (var s = 0; s < i; s++) a.push(o + s), a.push(o + s), a.push(e.readUshort(r, t)), t += 2
        }
        if (2 == n) {
            var h = e.readUshort(r, t);
            t += 2;
            for (s = 0; s < h; s++) a.push(e.readUshort(r, t)), a.push(e.readUshort(r, t += 2)), a.push(e.readUshort(r, t += 2)), t += 2
        }
        return a
    }, z._lctf.getInterval = function (r, t) {
        for (var e = 0; e < r.length; e += 3) {
            var a = r[e],
                n = r[e + 1];
            r[e + 2];
            if (a <= t && t <= n) return e
        }
        return -1
    }, z._lctf.readValueRecord = function (r, t, e) {
        var a = z._bin,
            n = [];
        return n.push(1 & e ? a.readShort(r, t) : 0), t += 1 & e ? 2 : 0, n.push(2 & e ? a.readShort(r, t) : 0), t += 2 & e ? 2 : 0, n.push(4 & e ? a.readShort(r, t) : 0), t += 4 & e ? 2 : 0, n.push(8 & e ? a.readShort(r, t) : 0), t += 8 & e ? 2 : 0, n
    }, z._lctf.readCoverage = function (r, t) {
        var e = z._bin,
            a = {};
        a.fmt = e.readUshort(r, t);
        var n = e.readUshort(r, t += 2);
        return t += 2, 1 == a.fmt && (a.tab = e.readUshorts(r, t, n)), 2 == a.fmt && (a.tab = e.readUshorts(r, t, 3 * n)), a
    }, z._lctf.coverageIndex = function (r, t) {
        var e = r.tab;
        if (1 == r.fmt) return e.indexOf(t);
        if (2 == r.fmt) {
            r = z._lctf.getInterval(e, t);
            if (-1 != r) return e[r + 2] + (t - e[r])
        }
        return -1
    }, z._lctf.readFeatureList = function (r, t) {
        var e = z._bin,
            a = t,
            n = [],
            o = e.readUshort(r, t);
        t += 2;
        for (var i = 0; i < o; i++) {
            var s = e.readASCII(r, t, 4);
            t += 4;
            var h = e.readUshort(r, t);
            t += 2, n.push({
                tag: s.trim(),
                tab: z._lctf.readFeatureTable(r, a + h)
            })
        }
        return n
    }, z._lctf.readFeatureTable = function (r, t) {
        var e = z._bin,
            a = (e.readUshort(r, t), e.readUshort(r, t += 2));
        t += 2;
        for (var n = [], o = 0; o < a; o++) n.push(e.readUshort(r, t + 2 * o));
        return n
    }, z._lctf.readScriptList = function (r, t) {
        var e = z._bin,
            a = t,
            n = {},
            o = e.readUshort(r, t);
        t += 2;
        for (var i = 0; i < o; i++) {
            var s = e.readASCII(r, t, 4);
            t += 4;
            var h = e.readUshort(r, t);
            t += 2, n[s.trim()] = z._lctf.readScriptTable(r, a + h)
        }
        return n
    }, z._lctf.readScriptTable = function (r, t) {
        var e = z._bin,
            a = t,
            n = {},
            o = e.readUshort(r, t);
        t += 2, n.default = z._lctf.readLangSysTable(r, a + o);
        var i = e.readUshort(r, t);
        t += 2;
        for (var s = 0; s < i; s++) {
            var h = e.readASCII(r, t, 4);
            t += 4;
            var f = e.readUshort(r, t);
            t += 2, n[h.trim()] = z._lctf.readLangSysTable(r, a + f)
        }
        return n
    }, z._lctf.readLangSysTable = function (r, t) {
        var e = z._bin,
            a = {};
        e.readUshort(r, t);
        a.reqFeature = e.readUshort(r, t += 2);
        var n = e.readUshort(r, t += 2);
        return a.features = e.readUshorts(r, t += 2, n), a
    }, z.CFF = {}, z.CFF.parse = function (r, t, e) {
        var a = z._bin,
            n = ((r = new Uint8Array(r.buffer, t, e))[t = 0], r[++t], r[++t], r[++t], []);
        t = z.CFF.readIndex(r, ++t, n);
        for (var o = [], i = 0; i < n.length - 1; i++) o.push(a.readASCII(r, t + n[i], n[i + 1] - n[i]));
        var s = [];
        t = z.CFF.readIndex(r, t += n[n.length - 1], s);
        for (var h = [], i = 0; i < s.length - 1; i++) h.push(z.CFF.readDict(r, t + s[i], t + s[i + 1]));
        var f = h[0],
            l = [];
        t = z.CFF.readIndex(r, t += s[s.length - 1], l);
        for (var u = [], i = 0; i < l.length - 1; i++) u.push(a.readASCII(r, t + l[i], l[i + 1] - l[i]));
        if (t += l[l.length - 1], z.CFF.readSubrs(r, t, f), f.CharStrings) {
            t = f.CharStrings, t = z.CFF.readIndex(r, t, l = []);
            for (var d = [], i = 0; i < l.length - 1; i++) d.push(a.readBytes(r, t + l[i], l[i + 1] - l[i]));
            f.CharStrings = d
        }
        f.Encoding && (f.Encoding = z.CFF.readEncoding(r, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = z.CFF.readCharset(r, f.charset, f.CharStrings.length)), f.Private && (t = f.Private[1], f.Private = z.CFF.readDict(r, t, t + f.Private[0]), f.Private.Subrs && z.CFF.readSubrs(r, t + f.Private.Subrs, f.Private));
        var c, p = {};
        for (c in f) - 1 != ["FamilyName", "FullName", "Notice", "version", "Copyright"].indexOf(c) ? p[c] = u[f[c] - 426 + 35] : p[c] = f[c];
        return p
    }, z.CFF.readSubrs = function (r, t, e) {
        var a = z._bin,
            n = [];
        t = z.CFF.readIndex(r, t, n);
        var o = n.length,
            o = o < 1240 ? 107 : o < 33900 ? 1131 : 32768;
        e.Bias = o, e.Subrs = [];
        for (var i = 0; i < n.length - 1; i++) e.Subrs.push(a.readBytes(r, t + n[i], n[i + 1] - n[i]))
    }, z.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], z.CFF.glyphByUnicode = function (r, t) {
        for (var e = 0; e < r.charset.length; e++)
            if (r.charset[e] == t) return e;
        return -1
    }, z.CFF.glyphBySE = function (r, t) {
        return t < 0 || 255 < t ? -1 : z.CFF.glyphByUnicode(r, z.CFF.tableSE[t])
    }, z.CFF.readEncoding = function (r, t, e) {
        z._bin;
        var a = [".notdef"],
            n = r[t];
        if (0 != n) throw "error: unknown encoding format: " + n;
        var o = r[++t];
        t++;
        for (var i = 0; i < o; i++) a.push(r[t + i]);
        return a
    }, z.CFF.readCharset = function (r, t, e) {
        var a = z._bin,
            n = [".notdef"],
            o = r[t];
        if (t++, 0 == o)
            for (var i = 0; i < e; i++) {
                var s = a.readUshort(r, t);
                t += 2, n.push(s)
            } else {
                if (1 != o && 2 != o) throw "error: format: " + o;
                for (; n.length < e;) {
                    s = a.readUshort(r, t);
                    t += 2;
                    var h = 0;
                    1 == o ? (h = r[t], t++) : (h = a.readUshort(r, t), t += 2);
                    for (i = 0; i <= h; i++) n.push(s), s++
                }
            }
        return n
    }, z.CFF.readIndex = function (r, t, e) {
        var a = z._bin,
            n = a.readUshort(r, t),
            o = r[t += 2];
        if (t++, 1 == o)
            for (var i = 0; i < n + 1; i++) e.push(r[t + i]);
        else if (2 == o)
            for (i = 0; i < n + 1; i++) e.push(a.readUshort(r, t + 2 * i));
        else if (3 == o)
            for (i = 0; i < n + 1; i++) e.push(16777215 & a.readUint(r, t + 3 * i - 1));
        else if (0 != n) throw "unsupported offset size: " + o + ", count: " + n;
        return (t += (n + 1) * o) - 1
    }, z.CFF.getCharString = function (r, t, e) {
        var a = z._bin,
            n = r[t],
            o = r[t + 1],
            i = (r[t + 2], r[t + 3], r[t + 4], 1),
            s = null,
            h = null;
        n <= 20 && (s = n, i = 1), 12 == n && (s = 100 * n + o, i = 2), 21 <= n && n <= 27 && (s = n, i = 1), 28 == n && (h = a.readShort(r, t + 1), i = 3), 29 <= n && n <= 31 && (s = n, i = 1), 32 <= n && n <= 246 && (h = n - 139, i = 1), 247 <= n && n <= 250 && (h = 256 * (n - 247) + o + 108, i = 2), 251 <= n && n <= 254 && (h = 256 * -(n - 251) - o - 108, i = 2), 255 == n && (h = a.readInt(r, t + 1) / 65535, i = 5), e.val = null != h ? h : "o" + s, e.size = i
    }, z.CFF.readCharString = function (r, t, e) {
        for (var a = t + e, n = z._bin, o = []; t < a;) {
            var i = r[t],
                s = r[t + 1],
                h = (r[t + 2], r[t + 3], r[t + 4], 1),
                f = null,
                l = null;
            i <= 20 && (f = i, h = 1), 12 == i && (f = 100 * i + s, h = 2), 19 != i && 20 != i || (f = i, h = 2), 21 <= i && i <= 27 && (f = i, h = 1), 28 == i && (l = n.readShort(r, t + 1), h = 3), 29 <= i && i <= 31 && (f = i, h = 1), 32 <= i && i <= 246 && (l = i - 139, h = 1), 247 <= i && i <= 250 && (l = 256 * (i - 247) + s + 108, h = 2), 251 <= i && i <= 254 && (l = 256 * -(i - 251) - s - 108, h = 2), 255 == i && (l = n.readInt(r, t + 1) / 65535, h = 5), o.push(null != l ? l : "o" + f), t += h
        }
        return o
    }, z.CFF.readDict = function (r, t, e) {
        for (var a = z._bin, n = {}, o = []; t < e;) {
            var i = r[t],
                s = r[t + 1],
                h = (r[t + 2], r[t + 3], r[t + 4], 1),
                f = null,
                l = null;
            if (28 == i && (l = a.readShort(r, t + 1), h = 3), 29 == i && (l = a.readInt(r, t + 1), h = 5), 32 <= i && i <= 246 && (l = i - 139, h = 1), 247 <= i && i <= 250 && (l = 256 * (i - 247) + s + 108, h = 2), 251 <= i && i <= 254 && (l = 256 * -(i - 251) - s - 108, h = 2), 255 == i) throw l = a.readInt(r, t + 1) / 65535, h = 5, "unknown number";
            if (30 == i) {
                for (var u = [], h = 1;;) {
                    var d = r[t + h];
                    h++;
                    var c = d >> 4,
                        d = 15 & d;
                    if (15 != c && u.push(c), 15 != d && u.push(d), 15 == d) break
                }
                for (var p = "", v = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], g = 0; g < u.length; g++) p += v[u[g]];
                l = parseFloat(p)
            }
            i <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], h = 1, 12 == i && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][s], h = 2)), null != f ? (n[f] = 1 == o.length ? o[0] : o, o = []) : o.push(l), t += h
        }
        return n
    }, z.cmap = {}, z.cmap.parse = function (r, t, e) {
        r = new Uint8Array(r.buffer, t, e);
        var a = z._bin,
            n = {},
            o = (a.readUshort(r, t = 0), a.readUshort(r, t += 2));
        t += 2;
        var i = [];
        n.tables = [];
        for (var s = 0; s < o; s++) {
            var h = a.readUshort(r, t);
            t += 2;
            var f = a.readUshort(r, t);
            t += 2;
            var l = a.readUint(r, t);
            t += 4;
            var u, d, c = "p" + h + "e" + f,
                p = i.indexOf(l);
            if (-1 == p && (p = n.tables.length, i.push(l), 0 == (d = a.readUshort(r, l)) ? u = z.cmap.parse0(r, l) : 4 == d ? u = z.cmap.parse4(r, l) : 6 == d ? u = z.cmap.parse6(r, l) : 12 == d ? u = z.cmap.parse12(r, l) : console.log("unknown format: " + d, h, f, l), n.tables.push(u)), null != n[c]) throw "multiple tables for one platform+encoding";
            n[c] = p
        }
        return n
    }, z.cmap.parse0 = function (r, t) {
        var e = z._bin,
            a = {};
        a.format = e.readUshort(r, t);
        var n = e.readUshort(r, t += 2);
        e.readUshort(r, t += 2);
        t += 2, a.map = [];
        for (var o = 0; o < n - 6; o++) a.map.push(r[t + o]);
        return a
    }, z.cmap.parse4 = function (r, t) {
        var e = z._bin,
            a = t,
            n = {};
        n.format = e.readUshort(r, t);
        var o = e.readUshort(r, t += 2),
            i = (e.readUshort(r, t += 2), e.readUshort(r, t += 2) / 2);
        n.searchRange = e.readUshort(r, t += 2), n.entrySelector = e.readUshort(r, t += 2), n.rangeShift = e.readUshort(r, t += 2), n.endCount = e.readUshorts(r, t += 2, i), t += 2 * i, n.startCount = e.readUshorts(r, t += 2, i), t += 2 * i, n.idDelta = [];
        for (var s = 0; s < i; s++) n.idDelta.push(e.readShort(r, t)), t += 2;
        for (n.idRangeOffset = e.readUshorts(r, t, i), t += 2 * i, n.glyphIdArray = []; t < a + o;) n.glyphIdArray.push(e.readUshort(r, t)), t += 2;
        return n
    }, z.cmap.parse6 = function (r, t) {
        var e = z._bin,
            a = {};
        a.format = e.readUshort(r, t);
        e.readUshort(r, t += 2), e.readUshort(r, t += 2);
        a.firstCode = e.readUshort(r, t += 2);
        var n = e.readUshort(r, t += 2);
        t += 2, a.glyphIdArray = [];
        for (var o = 0; o < n; o++) a.glyphIdArray.push(e.readUshort(r, t)), t += 2;
        return a
    }, z.cmap.parse12 = function (r, t) {
        var e = z._bin,
            a = {};
        a.format = e.readUshort(r, t), t += 2;
        e.readUint(r, t += 2), e.readUint(r, t += 4);
        var n = e.readUint(r, t += 4);
        t += 4, a.groups = [];
        for (var o = 0; o < n; o++) {
            var i = t + 12 * o,
                s = e.readUint(r, i + 0),
                h = e.readUint(r, i + 4),
                i = e.readUint(r, i + 8);
            a.groups.push([s, h, i])
        }
        return a
    }, z.glyf = {}, z.glyf.parse = function (r, t, e, a) {
        for (var n = [], o = 0; o < a.maxp.numGlyphs; o++) n.push(null);
        return n
    }, z.glyf._parseGlyf = function (r, t) {
        var e = z._bin,
            a = r._data,
            n = z._tabOffset(a, "glyf") + r.loca[t];
        if (r.loca[t] == r.loca[t + 1]) return null;
        var o = {};
        if (o.noc = e.readShort(a, n), o.xMin = e.readShort(a, n += 2), o.yMin = e.readShort(a, n += 2), o.xMax = e.readShort(a, n += 2), o.yMax = e.readShort(a, n += 2), n += 2, o.xMin >= o.xMax || o.yMin >= o.yMax) return null;
        if (0 < o.noc) {
            o.endPts = [];
            for (var i = 0; i < o.noc; i++) o.endPts.push(e.readUshort(a, n)), n += 2;
            t = e.readUshort(a, n);
            if (a.length - (n += 2) < t) return null;
            o.instructions = e.readBytes(a, n, t), n += t;
            var s = o.endPts[o.noc - 1] + 1;
            o.flags = [];
            for (i = 0; i < s; i++) {
                var h = a[n];
                if (n++, o.flags.push(h), 0 != (8 & h)) {
                    var f = a[n];
                    n++;
                    for (var l = 0; l < f; l++) o.flags.push(h), i++
                }
            }
            o.xs = [];
            for (i = 0; i < s; i++) {
                var u = 0 != (2 & o.flags[i]),
                    d = 0 != (16 & o.flags[i]);
                u ? (o.xs.push(d ? a[n] : -a[n]), n++) : d ? o.xs.push(0) : (o.xs.push(e.readShort(a, n)), n += 2)
            }
            o.ys = [];
            for (i = 0; i < s; i++) {
                u = 0 != (4 & o.flags[i]), d = 0 != (32 & o.flags[i]);
                u ? (o.ys.push(d ? a[n] : -a[n]), n++) : d ? o.ys.push(0) : (o.ys.push(e.readShort(a, n)), n += 2)
            }
            for (var c = 0, p = 0, i = 0; i < s; i++) c += o.xs[i], p += o.ys[i], o.xs[i] = c, o.ys[i] = p
        } else {
            var v;
            o.parts = [];
            do {
                v = e.readUshort(a, n), n += 2;
                var g, U, m = {
                    m: {
                        a: 1,
                        b: 0,
                        c: 0,
                        d: 1,
                        tx: 0,
                        ty: 0
                    },
                    p1: -1,
                    p2: -1
                }
            } while (o.parts.push(m), m.glyphIndex = e.readUshort(a, n), n += 2, 1 & v ? (g = e.readShort(a, n), U = e.readShort(a, n += 2), n += 2) : (g = e.readInt8(a, n), U = e.readInt8(a, ++n), n++), 2 & v ? (m.m.tx = g, m.m.ty = U) : (m.p1 = g, m.p2 = U), 8 & v ? (m.m.a = m.m.d = e.readF2dot14(a, n), n += 2) : 64 & v ? (m.m.a = e.readF2dot14(a, n), m.m.d = e.readF2dot14(a, n += 2), n += 2) : 128 & v && (m.m.a = e.readF2dot14(a, n), m.m.b = e.readF2dot14(a, n += 2), m.m.c = e.readF2dot14(a, n += 2), m.m.d = e.readF2dot14(a, n += 2), n += 2), 32 & v);
            if (256 & v) {
                var S = e.readUshort(a, n);
                n += 2, o.instr = [];
                for (i = 0; i < S; i++) o.instr.push(a[n]), n++
            }
        }
        return o
    }, z.GPOS = {}, z.GPOS.parse = function (r, t, e, a) {
        return z._lctf.parse(r, t, e, a, z.GPOS.subt)
    }, z.GPOS.subt = function (r, t, e) {
        if (2 != t) return null;
        var a = z._bin,
            n = e,
            o = {};
        o.format = a.readUshort(r, e);
        var i = a.readUshort(r, e += 2);
        e += 2, o.coverage = z._lctf.readCoverage(r, i + n), o.valFmt1 = a.readUshort(r, e), o.valFmt2 = a.readUshort(r, e += 2), e += 2;
        var s = z._lctf.numOfOnes(o.valFmt1),
            h = z._lctf.numOfOnes(o.valFmt2);
        if (1 == o.format) {
            o.pairsets = [];
            var f = a.readUshort(r, e);
            e += 2;
            for (var l = 0; l < f; l++) {
                var u = a.readUshort(r, e);
                e += 2, u += n;
                var d = a.readUshort(r, u);
                u += 2;
                for (var c = [], p = 0; p < d; p++) {
                    var v = a.readUshort(r, u);
                    u += 2, 0 != o.valFmt1 && (S = z._lctf.readValueRecord(r, u, o.valFmt1), u += 2 * s), 0 != o.valFmt2 && (b = z._lctf.readValueRecord(r, u, o.valFmt2), u += 2 * h), c.push({
                        gid2: v,
                        val1: S,
                        val2: b
                    })
                }
                o.pairsets.push(c)
            }
        }
        if (2 == o.format) {
            var t = a.readUshort(r, e),
                i = a.readUshort(r, e += 2),
                g = a.readUshort(r, e += 2),
                U = a.readUshort(r, e += 2);
            e += 2, o.classDef1 = z._lctf.readClassDef(r, n + t), o.classDef2 = z._lctf.readClassDef(r, n + i), o.matrix = [];
            for (l = 0; l < g; l++) {
                for (var m = [], p = 0; p < U; p++) {
                    var S = null,
                        b = null;
                    0 != o.valFmt1 && (S = z._lctf.readValueRecord(r, e, o.valFmt1), e += 2 * s), 0 != o.valFmt2 && (b = z._lctf.readValueRecord(r, e, o.valFmt2), e += 2 * h), m.push({
                        val1: S,
                        val2: b
                    })
                }
                o.matrix.push(m)
            }
        }
        return o
    }, z.GSUB = {}, z.GSUB.parse = function (r, t, e, a) {
        return z._lctf.parse(r, t, e, a, z.GSUB.subt)
    }, z.GSUB.subt = function (r, t, e) {
        var a = z._bin,
            n = e,
            o = {};
        if (1 != t && 4 != t && 5 != t) return null;
        o.fmt = a.readUshort(r, e);
        var i = a.readUshort(r, e += 2);
        if (e += 2, o.coverage = z._lctf.readCoverage(r, i + n), 1 == t) 1 == o.fmt ? (o.delta = a.readShort(r, e), e += 2) : 2 == o.fmt && (s = a.readUshort(r, e), o.newg = a.readUshorts(r, e += 2, s), e += 2 * o.newg.length);
        else if (4 == t) {
            o.vals = [];
            var s = a.readUshort(r, e);
            e += 2;
            for (var h = 0; h < s; h++) {
                var f = a.readUshort(r, e);
                e += 2, o.vals.push(z.GSUB.readLigatureSet(r, n + f))
            }
        } else if (5 == t)
            if (2 == o.fmt) {
                t = a.readUshort(r, e);
                e += 2, o.cDef = z._lctf.readClassDef(r, n + t), o.scset = [];
                var l = a.readUshort(r, e);
                e += 2;
                for (h = 0; h < l; h++) {
                    var u = a.readUshort(r, e);
                    e += 2, o.scset.push(0 == u ? null : z.GSUB.readSubClassSet(r, n + u))
                }
            } else console.log("unknown table format", o.fmt);
        return o
    }, z.GSUB.readSubClassSet = function (r, t) {
        var e = z._bin.readUshort,
            a = t,
            n = [],
            o = e(r, t);
        t += 2;
        for (var i = 0; i < o; i++) {
            var s = e(r, t);
            t += 2, n.push(z.GSUB.readSubClassRule(r, a + s))
        }
        return n
    }, z.GSUB.readSubClassRule = function (r, t) {
        var e = z._bin.readUshort,
            a = {},
            n = e(r, t),
            o = e(r, t += 2);
        t += 2, a.input = [];
        for (var i = 0; i < n - 1; i++) a.input.push(e(r, t)), t += 2;
        return a.substLookupRecords = z.GSUB.readSubstLookupRecords(r, t, o), a
    }, z.GSUB.readSubstLookupRecords = function (r, t, e) {
        for (var a = z._bin.readUshort, n = [], o = 0; o < e; o++) n.push(a(r, t), a(r, t + 2)), t += 4;
        return n
    }, z.GSUB.readChainSubClassSet = function (r, t) {
        var e = z._bin,
            a = t,
            n = [],
            o = e.readUshort(r, t);
        t += 2;
        for (var i = 0; i < o; i++) {
            var s = e.readUshort(r, t);
            t += 2, n.push(z.GSUB.readChainSubClassRule(r, a + s))
        }
        return n
    }, z.GSUB.readChainSubClassRule = function (r, t) {
        for (var e = z._bin, a = {}, n = ["backtrack", "input", "lookahead"], o = 0; o < n.length; o++) {
            var i = e.readUshort(r, t);
            t += 2, 1 == o && i--, a[n[o]] = e.readUshorts(r, t, i), t += 2 * a[n[o]].length
        }
        i = e.readUshort(r, t);
        return a.subst = e.readUshorts(r, t += 2, 2 * i), t += 2 * a.subst.length, a
    }, z.GSUB.readLigatureSet = function (r, t) {
        var e = z._bin,
            a = t,
            n = [],
            o = e.readUshort(r, t);
        t += 2;
        for (var i = 0; i < o; i++) {
            var s = e.readUshort(r, t);
            t += 2, n.push(z.GSUB.readLigature(r, a + s))
        }
        return n
    }, z.GSUB.readLigature = function (r, t) {
        var e = z._bin,
            a = {
                chain: []
            };
        a.nglyph = e.readUshort(r, t);
        var n = e.readUshort(r, t += 2);
        t += 2;
        for (var o = 0; o < n - 1; o++) a.chain.push(e.readUshort(r, t)), t += 2;
        return a
    }, z.head = {}, z.head.parse = function (r, t, e) {
        var a = z._bin,
            n = {};
        a.readFixed(r, t);
        n.fontRevision = a.readFixed(r, t += 4);
        a.readUint(r, t += 4), a.readUint(r, t += 4);
        return n.flags = a.readUshort(r, t += 4), n.unitsPerEm = a.readUshort(r, t += 2), n.created = a.readUint64(r, t += 2), n.modified = a.readUint64(r, t += 8), n.xMin = a.readShort(r, t += 8), n.yMin = a.readShort(r, t += 2), n.xMax = a.readShort(r, t += 2), n.yMax = a.readShort(r, t += 2), n.macStyle = a.readUshort(r, t += 2), n.lowestRecPPEM = a.readUshort(r, t += 2), n.fontDirectionHint = a.readShort(r, t += 2), n.indexToLocFormat = a.readShort(r, t += 2), n.glyphDataFormat = a.readShort(r, t += 2), t += 2, n
    }, z.hhea = {}, z.hhea.parse = function (r, t, e) {
        var a = z._bin,
            n = {};
        a.readFixed(r, t);
        return n.ascender = a.readShort(r, t += 4), n.descender = a.readShort(r, t += 2), n.lineGap = a.readShort(r, t += 2), n.advanceWidthMax = a.readUshort(r, t += 2), n.minLeftSideBearing = a.readShort(r, t += 2), n.minRightSideBearing = a.readShort(r, t += 2), n.xMaxExtent = a.readShort(r, t += 2), n.caretSlopeRise = a.readShort(r, t += 2), n.caretSlopeRun = a.readShort(r, t += 2), n.caretOffset = a.readShort(r, t += 2), t += 2, n.metricDataFormat = a.readShort(r, t += 8), n.numberOfHMetrics = a.readUshort(r, t += 2), t += 2, n
    }, z.hmtx = {}, z.hmtx.parse = function (r, t, e, a) {
        for (var n = z._bin, o = {
                aWidth: [],
                lsBearing: []
            }, i = 0, s = 0, h = 0; h < a.maxp.numGlyphs; h++) h < a.hhea.numberOfHMetrics && (i = n.readUshort(r, t), s = n.readShort(r, t += 2), t += 2), o.aWidth.push(i), o.lsBearing.push(s);
        return o
    }, z.kern = {}, z.kern.parse = function (r, t, e, a) {
        var n = z._bin,
            o = n.readUshort(r, t);
        if (t += 2, 1 == o) return z.kern.parseV1(r, t - 2, e, a);
        var i = n.readUshort(r, t);
        t += 2;
        for (var s = {
                glyph1: [],
                rval: []
            }, h = 0; h < i; h++) {
            t += 2;
            e = n.readUshort(r, t);
            t += 2;
            var f = n.readUshort(r, t);
            t += 2;
            f = f >>> 8;
            if (0 != (f &= 15)) throw "unknown kern table format: " + f;
            t = z.kern.readFormat0(r, t, s)
        }
        return s
    }, z.kern.parseV1 = function (r, t, e, a) {
        var n = z._bin,
            o = (n.readFixed(r, t), n.readUint(r, t += 4));
        t += 4;
        for (var i = {
                glyph1: [],
                rval: []
            }, s = 0; s < o; s++) {
            n.readUint(r, t);
            t += 4;
            var h = n.readUshort(r, t);
            t += 2;
            n.readUshort(r, t);
            t += 2;
            h = h >>> 8;
            if (0 != (h &= 15)) throw "unknown kern table format: " + h;
            t = z.kern.readFormat0(r, t, i)
        }
        return i
    }, z.kern.readFormat0 = function (r, t, e) {
        var a = z._bin,
            n = -1,
            o = a.readUshort(r, t);
        a.readUshort(r, t += 2), a.readUshort(r, t += 2), a.readUshort(r, t += 2);
        t += 2;
        for (var i = 0; i < o; i++) {
            var s = a.readUshort(r, t);
            t += 2;
            var h = a.readUshort(r, t);
            t += 2;
            var f = a.readShort(r, t);
            t += 2, s != n && (e.glyph1.push(s), e.rval.push({
                glyph2: [],
                vals: []
            }));
            var l = e.rval[e.rval.length - 1];
            l.glyph2.push(h), l.vals.push(f), n = s
        }
        return t
    }, z.loca = {}, z.loca.parse = function (r, t, e, a) {
        var n = z._bin,
            o = [],
            i = a.head.indexToLocFormat,
            s = a.maxp.numGlyphs + 1;
        if (0 == i)
            for (var h = 0; h < s; h++) o.push(n.readUshort(r, t + (h << 1)) << 1);
        if (1 == i)
            for (h = 0; h < s; h++) o.push(n.readUint(r, t + (h << 2)));
        return o
    }, z.maxp = {}, z.maxp.parse = function (r, t, e) {
        var a = z._bin,
            n = {},
            o = a.readUint(r, t);
        return n.numGlyphs = a.readUshort(r, t += 4), t += 2, 65536 == o && (n.maxPoints = a.readUshort(r, t), n.maxContours = a.readUshort(r, t += 2), n.maxCompositePoints = a.readUshort(r, t += 2), n.maxCompositeContours = a.readUshort(r, t += 2), n.maxZones = a.readUshort(r, t += 2), n.maxTwilightPoints = a.readUshort(r, t += 2), n.maxStorage = a.readUshort(r, t += 2), n.maxFunctionDefs = a.readUshort(r, t += 2), n.maxInstructionDefs = a.readUshort(r, t += 2), n.maxStackElements = a.readUshort(r, t += 2), n.maxSizeOfInstructions = a.readUshort(r, t += 2), n.maxComponentElements = a.readUshort(r, t += 2), n.maxComponentDepth = a.readUshort(r, t += 2), t += 2), n
    }, z.name = {}, z.name.parse = function (r, t, e) {
        for (var a, n, o = z._bin, i = {}, s = (o.readUshort(r, t), o.readUshort(r, t += 2)), h = (o.readUshort(r, t += 2), t += 2), f = 0; f < s; f++) {
            var l = o.readUshort(r, t);
            t += 2;
            var u = o.readUshort(r, t);
            t += 2;
            var d = o.readUshort(r, t);
            t += 2;
            var c = o.readUshort(r, t);
            t += 2;
            e = o.readUshort(r, t);
            t += 2;
            var p = o.readUshort(r, t);
            t += 2;
            var v = "p" + l;
            null == i[v] && (i[v] = {});
            var g, c = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"][c],
                p = h + 12 * s + p;
            if (0 == l) g = o.readUnicode(r, p, e / 2);
            else if (3 == l && 0 == u) g = o.readUnicode(r, p, e / 2);
            else if (0 == u) g = o.readASCII(r, p, e);
            else if (1 == u) g = o.readUnicode(r, p, e / 2);
            else if (3 == u) g = o.readUnicode(r, p, e / 2);
            else {
                if (1 != l) throw "unknown encoding " + u + ", platformID: " + l;
                g = o.readASCII(r, p, e), console.log("reading unknown MAC encoding " + u + " as ASCII")
            }
            i[v][c] = g, i[v]._lang = d
        }
        for (n in i)
            if (null != i[n].postScriptName && 1033 == i[n]._lang) return i[n];
        for (n in i)
            if (null != i[n].postScriptName && 3084 == i[n]._lang) return i[n];
        for (n in i)
            if (null != i[n].postScriptName) return i[n];
        for (n in i) {
            a = n;
            break
        }
        return console.log("returning name table with languageID " + i[a]._lang), i[a]
    }, z["OS/2"] = {}, z["OS/2"].parse = function (r, t, e) {
        var a = z._bin.readUshort(r, t);
        t += 2;
        var n = {};
        if (0 == a) z["OS/2"].version0(r, t, n);
        else if (1 == a) z["OS/2"].version1(r, t, n);
        else if (2 == a || 3 == a || 4 == a) z["OS/2"].version2(r, t, n);
        else {
            if (5 != a) throw "unknown OS/2 table version: " + a;
            z["OS/2"].version5(r, t, n)
        }
        return n
    }, z["OS/2"].version0 = function (r, t, e) {
        var a = z._bin;
        return e.xAvgCharWidth = a.readShort(r, t), e.usWeightClass = a.readUshort(r, t += 2), e.usWidthClass = a.readUshort(r, t += 2), e.fsType = a.readUshort(r, t += 2), e.ySubscriptXSize = a.readShort(r, t += 2), e.ySubscriptYSize = a.readShort(r, t += 2), e.ySubscriptXOffset = a.readShort(r, t += 2), e.ySubscriptYOffset = a.readShort(r, t += 2), e.ySuperscriptXSize = a.readShort(r, t += 2), e.ySuperscriptYSize = a.readShort(r, t += 2), e.ySuperscriptXOffset = a.readShort(r, t += 2), e.ySuperscriptYOffset = a.readShort(r, t += 2), e.yStrikeoutSize = a.readShort(r, t += 2), e.yStrikeoutPosition = a.readShort(r, t += 2), e.sFamilyClass = a.readShort(r, t += 2), e.panose = a.readBytes(r, t += 2, 10), e.ulUnicodeRange1 = a.readUint(r, t += 10), e.ulUnicodeRange2 = a.readUint(r, t += 4), e.ulUnicodeRange3 = a.readUint(r, t += 4), e.ulUnicodeRange4 = a.readUint(r, t += 4), e.achVendID = [a.readInt8(r, t += 4), a.readInt8(r, t + 1), a.readInt8(r, t + 2), a.readInt8(r, t + 3)], e.fsSelection = a.readUshort(r, t += 4), e.usFirstCharIndex = a.readUshort(r, t += 2), e.usLastCharIndex = a.readUshort(r, t += 2), e.sTypoAscender = a.readShort(r, t += 2), e.sTypoDescender = a.readShort(r, t += 2), e.sTypoLineGap = a.readShort(r, t += 2), e.usWinAscent = a.readUshort(r, t += 2), e.usWinDescent = a.readUshort(r, t += 2), t += 2
    }, z["OS/2"].version1 = function (r, t, e) {
        var a = z._bin;
        return t = z["OS/2"].version0(r, t, e), e.ulCodePageRange1 = a.readUint(r, t), e.ulCodePageRange2 = a.readUint(r, t += 4), t += 4
    }, z["OS/2"].version2 = function (r, t, e) {
        var a = z._bin;
        return t = z["OS/2"].version1(r, t, e), e.sxHeight = a.readShort(r, t), e.sCapHeight = a.readShort(r, t += 2), e.usDefault = a.readUshort(r, t += 2), e.usBreak = a.readUshort(r, t += 2), e.usMaxContext = a.readUshort(r, t += 2), t += 2
    }, z["OS/2"].version5 = function (r, t, e) {
        var a = z._bin;
        return t = z["OS/2"].version2(r, t, e), e.usLowerOpticalPointSize = a.readUshort(r, t), e.usUpperOpticalPointSize = a.readUshort(r, t += 2), t += 2
    }, z.post = {}, z.post.parse = function (r, t, e) {
        var a = z._bin,
            n = {};
        return n.version = a.readFixed(r, t), n.italicAngle = a.readFixed(r, t += 4), n.underlinePosition = a.readShort(r, t += 4), n.underlineThickness = a.readShort(r, t += 2), t += 2, n
    }, z.SVG = {}, z.SVG.parse = function (r, t, e) {
        var a = z._bin,
            n = {
                entries: []
            },
            o = t,
            i = (a.readUshort(r, t), a.readUint(r, t += 2));
        a.readUint(r, t += 4);
        t += 4;
        var s = a.readUshort(r, t = i + o);
        t += 2;
        for (var h = 0; h < s; h++) {
            var f = a.readUshort(r, t);
            t += 2;
            var l = a.readUshort(r, t);
            t += 2;
            var u = a.readUint(r, t);
            t += 4;
            var d = a.readUint(r, t);
            t += 4;
            for (var d = new Uint8Array(r.buffer, o + u + i, d), c = a.readUTF8(d, 0, d.length), p = f; p <= l; p++) n.entries[p] = c
        }
        return n
    }, z.SVG.toPath = function (r) {
        var t = {
            cmds: [],
            crds: []
        };
        if (null == r) return t;
        for (var e = (new DOMParser).parseFromString(r, "image/svg+xml").firstChild;
            "svg" != e.tagName;) e = e.nextSibling;
        var a = (a = e.getAttribute("viewBox")) ? a.trim().split(" ").map(parseFloat) : [0, 0, 1e3, 1e3];
        z.SVG._toPath(e.children, t);
        for (var n = 0; n < t.crds.length; n += 2) {
            var o = t.crds[n],
                i = t.crds[n + 1];
            o -= a[0], i = -(i -= a[1]), t.crds[n] = o, t.crds[n + 1] = i
        }
        return t
    }, z.SVG._toPath = function (r, t, e) {
        for (var a = 0; a < r.length; a++) {
            var n = r[a],
                o = n.tagName,
                i = n.getAttribute("fill");
            null == i && (i = e), "g" == o ? z.SVG._toPath(n.children, t, i) : "path" == o ? (t.cmds.push(i || "#000000"), i = n.getAttribute("d"), i = z.SVG._tokens(i), z.SVG._toksToPath(i, t), t.cmds.push("X")) : "defs" == o || console.log(o, n)
        }
    }, z.SVG._tokens = function (r) {
        for (var t = [], e = 0, a = !1, n = ""; e < r.length;) {
            var o = r.charCodeAt(e),
                i = r.charAt(e);
            e++;
            o = 48 <= o && o <= 57 || "." == i || "-" == i;
            a ? "-" == i ? (t.push(parseFloat(n)), n = i) : o ? n += i : (t.push(parseFloat(n)), "," != i && " " != i && t.push(i), a = !1) : o ? (n = i, a = !0) : "," != i && " " != i && t.push(i)
        }
        return a && t.push(parseFloat(n)), t
    }, z.SVG._toksToPath = function (r, t) {
        for (var e = 0, a = 0, n = 0, o = 0, i = 0, s = {
                M: 2,
                L: 2,
                H: 1,
                V: 1,
                S: 4,
                C: 6
            }, h = t.cmds, f = t.crds; e < r.length;) {
            var l = r[e];
            if (e++, "z" == l) h.push("Z"), a = o, n = i;
            else
                for (var u = l.toUpperCase(), d = z.SVG._reps(r, e, s[u]), c = 0; c < d; c++) {
                    var p, v, g, U, m, S, b, _ = 0,
                        y = 0;
                    l != u && (_ = a, y = n), "M" == u ? (a = _ + r[e++], n = y + r[e++], h.push("M"), f.push(a, n), o = a, i = n) : "L" == u ? (a = _ + r[e++], n = y + r[e++], h.push("L"), f.push(a, n)) : "H" == u ? (a = _ + r[e++], h.push("L"), f.push(a, n)) : "V" == u ? (n = y + r[e++], h.push("L"), f.push(a, n)) : "C" == u ? (v = _ + r[e++], g = y + r[e++], U = _ + r[e++], m = y + r[e++], S = _ + r[e++], b = y + r[e++], h.push("C"), f.push(v, g, U, m, S, b), a = S, n = b) : "S" == u ? (v = a + a - f[p = Math.max(f.length - 4, 0)], g = n + n - f[p + 1], U = _ + r[e++], m = y + r[e++], S = _ + r[e++], b = y + r[e++], h.push("C"), f.push(v, g, U, m, S, b), a = S, n = b) : console.log("Unknown SVG command " + l)
                }
        }
    }, z.SVG._reps = function (r, t, e) {
        for (var a = t; a < r.length && "string" != typeof r[a];) a += e;
        return (a - t) / e
    }, null == (z = null == z ? {} : z).U && (z.U = {}), z.U.codeToGlyph = function (r, t) {
        var e = r.cmap,
            r = -1;
        if (null != e.p0e4 ? r = e.p0e4 : null != e.p3e1 ? r = e.p3e1 : null != e.p1e0 && (r = e.p1e0), -1 == r) throw "no familiar platform and encoding!";
        var a = e.tables[r];
        if (0 == a.format) return t >= a.map.length ? 0 : a.map[t];
        if (4 == a.format) {
            for (var n = -1, o = 0; o < a.endCount.length; o++)
                if (t <= a.endCount[o]) {
                    n = o;
                    break
                } if (-1 == n) return 0;
            if (a.startCount[n] > t) return 0;
            return 65535 & (0 != a.idRangeOffset[n] ? a.glyphIdArray[t - a.startCount[n] + (a.idRangeOffset[n] >> 1) - (a.idRangeOffset.length - n)] : t + a.idDelta[n])
        }
        if (12 != a.format) throw "unknown cmap table format " + a.format;
        if (t > a.groups[a.groups.length - 1][1]) return 0;
        for (o = 0; o < a.groups.length; o++) {
            var i = a.groups[o];
            if (i[0] <= t && t <= i[1]) return i[2] + (t - i[0])
        }
        return 0
    }, z.U.glyphToPath = function (r, t) {
        var e = {
            cmds: [],
            crds: []
        };
        if (r.SVG && r.SVG.entries[t]) {
            var a = r.SVG.entries[t];
            return null == a ? e : ("string" == typeof a && (a = z.SVG.toPath(a), r.SVG.entries[t] = a), a)
        }
        return r.CFF ? (a = {
            x: 0,
            y: 0,
            stack: [],
            nStems: 0,
            haveWidth: !1,
            width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0,
            open: !1
        }, z.U._drawCFF(r.CFF.CharStrings[t], a, r.CFF, e)) : r.glyf && z.U._drawGlyf(t, r, e), e
    }, z.U._drawGlyf = function (r, t, e) {
        var a = t.glyf[r];
        null != (a = null == a ? t.glyf[r] = z.glyf._parseGlyf(t, r) : a) && (-1 < a.noc ? z.U._simpleGlyph(a, e) : z.U._compoGlyph(a, t, e))
    }, z.U._simpleGlyph = function (r, t) {
        for (var e = 0; e < r.noc; e++) {
            for (var a = 0 == e ? 0 : r.endPts[e - 1] + 1, n = r.endPts[e], o = a; o <= n; o++) {
                var i = o == a ? n : o - 1,
                    s = o == n ? a : o + 1,
                    h = 1 & r.flags[o],
                    f = 1 & r.flags[i],
                    l = 1 & r.flags[s],
                    u = r.xs[o],
                    d = r.ys[o];
                if (o == a)
                    if (h) {
                        if (!f) {
                            z.U.P.moveTo(t, u, d);
                            continue
                        }
                        z.U.P.moveTo(t, r.xs[i], r.ys[i])
                    } else f ? z.U.P.moveTo(t, r.xs[i], r.ys[i]) : z.U.P.moveTo(t, (r.xs[i] + u) / 2, (r.ys[i] + d) / 2);
                h ? f && z.U.P.lineTo(t, u, d) : l ? z.U.P.qcurveTo(t, u, d, r.xs[s], r.ys[s]) : z.U.P.qcurveTo(t, u, d, (u + r.xs[s]) / 2, (d + r.ys[s]) / 2)
            }
            z.U.P.closePath(t)
        }
    }, z.U._compoGlyph = function (r, t, e) {
        for (var a = 0; a < r.parts.length; a++) {
            var n = {
                    cmds: [],
                    crds: []
                },
                o = r.parts[a];
            z.U._drawGlyf(o.glyphIndex, t, n);
            for (var i = o.m, s = 0; s < n.crds.length; s += 2) {
                var h = n.crds[s],
                    f = n.crds[s + 1];
                e.crds.push(h * i.a + f * i.b + i.tx), e.crds.push(h * i.c + f * i.d + i.ty)
            }
            for (s = 0; s < n.cmds.length; s++) e.cmds.push(n.cmds[s])
        }
    }, z.U._getGlyphClass = function (r, t) {
        r = z._lctf.getInterval(t, r);
        return -1 == r ? 0 : t[r + 2]
    }, z.U.getPairAdjustment = function (r, t, e) {
        if (r.GPOS) {
            for (var a = null, n = 0; n < r.GPOS.featureList.length; n++) {
                var o = r.GPOS.featureList[n];
                if ("kern" == o.tag)
                    for (var i = 0; i < o.tab.length; i++) 2 == r.GPOS.lookupList[o.tab[i]].ltype && (a = r.GPOS.lookupList[o.tab[i]])
            }
            if (a)
                for (n = 0; n < a.tabs.length; n++) {
                    var s, h, f = a.tabs[n],
                        l = z._lctf.coverageIndex(f.coverage, t);
                    if (-1 != l) {
                        if (1 == f.format) {
                            for (var u = f.pairsets[l], i = 0; i < u.length; i++) u[i].gid2 == e && (h = u[i]);
                            if (null == h) continue
                        } else 2 == f.format && (s = z.U._getGlyphClass(t, f.classDef1), l = z.U._getGlyphClass(e, f.classDef2), h = f.matrix[s][l]);
                        return h.val1[2]
                    }
                }
        }
        if (r.kern) {
            var d = r.kern.glyph1.indexOf(t);
            if (-1 != d) {
                var c = r.kern.rval[d].glyph2.indexOf(e);
                if (-1 != c) return r.kern.rval[d].vals[c]
            }
        }
        return 0
    }, z.U.stringToGlyphs = function (r, t) {
        for (var e = [], a = 0; a < t.length; a++) {
            var n = t.codePointAt(a);
            65535 < n && a++, e.push(z.U.codeToGlyph(r, n))
        }
        var o = r.GSUB;
        if (null == o) return e;
        for (var i = o.lookupList, s = o.featureList, h = '\n\t" ,.:;!?()  ،', f = "آأؤإاةدذرزوٱٲٳٵٶٷڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙۀۃۄۅۆۇۈۉۊۋۍۏےۓەۮۯܐܕܖܗܘܙܞܨܪܬܯݍݙݚݛݫݬݱݳݴݸݹࡀࡆࡇࡉࡔࡧࡩࡪࢪࢫࢬࢮࢱࢲࢹૅેૉ૊૎૏ૐ૑૒૝ૡ૤૯஁ஃ஄அஉ஌எஏ஑னப஫஬", l = 0; l < e.length; l++) {
            var u = e[l],
                d = 0 == l || -1 != h.indexOf(t[l - 1]),
                c = l == e.length - 1 || -1 != h.indexOf(t[l + 1]);
            d || -1 == f.indexOf(t[l - 1]) || (d = !0), (c = !c && -1 != f.indexOf(t[l]) ? !0 : c) || -1 == "ꡲ્૗".indexOf(t[l + 1]) || (c = !0);
            for (var p = null, p = (d = !d && -1 != "ꡲ્૗".indexOf(t[l]) ? !0 : d) ? c ? "isol" : "init" : c ? "fina" : "medi", v = 0; v < s.length; v++)
                if (s[v].tag == p)
                    for (var g = 0; g < s[v].tab.length; g++) 1 == (b = i[s[v].tab[g]]).ltype && z.U._applyType1(e, l, b)
        }
        for (var U = ["rlig", "liga", "mset"], l = 0; l < e.length; l++)
            for (var u = e[l], m = Math.min(3, e.length - l - 1), v = 0; v < s.length; v++) {
                var S = s[v];
                if (-1 != U.indexOf(S.tag))
                    for (g = 0; g < S.tab.length; g++)
                        for (var b = i[S.tab[g]], _ = 0; _ < b.tabs.length; _++)
                            if (null != b.tabs[_]) {
                                var y = z._lctf.coverageIndex(b.tabs[_].coverage, u);
                                if (-1 != y)
                                    if (4 == b.ltype)
                                        for (var x = b.tabs[_].vals[y], F = 0; F < x.length; F++) {
                                            var C = x[F],
                                                P = C.chain.length;
                                            if (!(m < P)) {
                                                for (var T = !0, w = 0; w < P; w++) C.chain[w] != e[l + (1 + w)] && (T = !1);
                                                if (T) {
                                                    e[l] = C.nglyph;
                                                    for (w = 0; w < P; w++) e[l + w + 1] = -1
                                                }
                                            }
                                        } else if (5 == b.ltype) {
                                            var G = b.tabs[_];
                                            if (2 == G.fmt)
                                                for (var k = z._lctf.getInterval(G.cDef, u), y = G.cDef[k + 2], O = G.scset[y], a = 0; a < O.length; a++) {
                                                    var I = O[a],
                                                        A = I.input;
                                                    if (!(A.length > m)) {
                                                        for (T = !0, w = 0; w < A.length; w++) {
                                                            var B = z._lctf.getInterval(G.cDef, e[l + 1 + w]);
                                                            if (-1 == k && G.cDef[B + 2] != A[w]) {
                                                                T = !1;
                                                                break
                                                            }
                                                        }
                                                        if (T)
                                                            for (var L = I.substLookupRecords, F = 0; F < L.length; F += 2) L[F], L[F + 1]
                                                    }
                                                }
                                        }
                            }
            }
        return e
    }, z.U._applyType1 = function (r, t, e) {
        for (var a = r[t], n = 0; n < e.tabs.length; n++) {
            var o = e.tabs[n],
                i = z._lctf.coverageIndex(o.coverage, a); - 1 != i && (1 == o.fmt ? r[t] = r[t] + o.delta : r[t] = o.newg[i])
        }
    }, z.U.glyphsToPath = function (r, t, e) {
        for (var a = {
                cmds: [],
                crds: []
            }, n = 0, o = 0; o < t.length; o++) {
            var i = t[o];
            if (-1 != i) {
                for (var s = o < t.length - 1 && -1 != t[o + 1] ? t[o + 1] : 0, h = z.U.glyphToPath(r, i), f = 0; f < h.crds.length; f += 2) a.crds.push(h.crds[f] + n), a.crds.push(h.crds[f + 1]);
                e && a.cmds.push(e);
                for (f = 0; f < h.cmds.length; f++) a.cmds.push(h.cmds[f]);
                e && a.cmds.push("X"), n += r.hmtx.aWidth[i], o < t.length - 1 && (n += z.U.getPairAdjustment(r, i, s))
            }
        }
        return a
    }, z.U.pathToSVG = function (r, t) {
        null == t && (t = 5);
        for (var e = [], a = 0, n = {
                M: 2,
                L: 2,
                Q: 4,
                C: 6
            }, o = 0; o < r.cmds.length; o++) {
            var i = r.cmds[o],
                s = a + (n[i] || 0);
            for (e.push(i); a < s;) {
                var h = r.crds[a++];
                e.push(parseFloat(h.toFixed(t)) + (a == s ? "" : " "))
            }
        }
        return e.join("")
    }, z.U.pathToContext = function (r, t) {
        for (var e = 0, a = r.crds, n = 0; n < r.cmds.length; n++) {
            var o = r.cmds[n];
            "M" == o ? (t.moveTo(a[e], a[e + 1]), e += 2) : "L" == o ? (t.lineTo(a[e], a[e + 1]), e += 2) : "C" == o ? (t.bezierCurveTo(a[e], a[e + 1], a[e + 2], a[e + 3], a[e + 4], a[e + 5]), e += 6) : "Q" == o ? (t.quadraticCurveTo(a[e], a[e + 1], a[e + 2], a[e + 3]), e += 4) : "#" == o.charAt(0) ? (t.beginPath(), t.fillStyle = o) : "Z" == o ? t.closePath() : "X" == o && t.fill()
        }
    }, z.U.P = {}, z.U.P.moveTo = function (r, t, e) {
        r.cmds.push("M"), r.crds.push(t, e)
    }, z.U.P.lineTo = function (r, t, e) {
        r.cmds.push("L"), r.crds.push(t, e)
    }, z.U.P.curveTo = function (r, t, e, a, n, o, i) {
        r.cmds.push("C"), r.crds.push(t, e, a, n, o, i)
    }, z.U.P.qcurveTo = function (r, t, e, a, n) {
        r.cmds.push("Q"), r.crds.push(t, e, a, n)
    }, z.U.P.closePath = function (r) {
        r.cmds.push("Z")
    }, z.U._drawCFF = function (r, t, e, a) {
        for (var n = t.stack, o = t.nStems, i = t.haveWidth, s = t.width, h = t.open, f = 0, l = t.x, u = t.y, d = 0, c = 0, p = 0, v = 0, g = 0, U = 0, m = 0, S = 0, b = 0, _ = 0, y = {
                val: 0,
                size: 0
            }; f < r.length;) {
            z.CFF.getCharString(r, f, y);
            var x, F, C, P = y.val;
            if (f += y.size, "o1" == P || "o18" == P) n.length % 2 != 0 && !i && (s = n.shift() + e.Private.nominalWidthX), o += n.length >> 1, i = !(n.length = 0);
            else if ("o3" == P || "o23" == P) n.length % 2 != 0 && !i && (s = n.shift() + e.Private.nominalWidthX), o += n.length >> 1, i = !(n.length = 0);
            else if ("o4" == P) 1 < n.length && !i && (s = n.shift() + e.Private.nominalWidthX, i = !0), h && z.U.P.closePath(a), u += n.pop(), z.U.P.moveTo(a, l, u), h = !0;
            else if ("o5" == P)
                for (; 0 < n.length;) l += n.shift(), u += n.shift(), z.U.P.lineTo(a, l, u);
            else if ("o6" == P || "o7" == P)
                for (var T = n.length, w = "o6" == P, G = 0; G < T; G++) {
                    var k = n.shift();
                    w ? l += k : u += k, w = !w, z.U.P.lineTo(a, l, u)
                } else if ("o8" == P || "o24" == P) {
                    for (var T = n.length, O = 0; O + 6 <= T;) d = l + n.shift(), c = u + n.shift(), p = d + n.shift(), v = c + n.shift(), l = p + n.shift(), u = v + n.shift(), z.U.P.curveTo(a, d, c, p, v, l, u), O += 6;
                    "o24" == P && (l += n.shift(), u += n.shift(), z.U.P.lineTo(a, l, u))
                } else {
                    if ("o11" == P) break;
                    if ("o1234" == P || "o1235" == P || "o1236" == P || "o1237" == P) "o1234" == P && (c = u, p = (d = l + n.shift()) + n.shift(), U = _ = v = c + n.shift(), S = u, l = (m = (g = (b = p + n.shift()) + n.shift()) + n.shift()) + n.shift(), z.U.P.curveTo(a, d, c, p, v, b, _), z.U.P.curveTo(a, g, U, m, S, l, u)), "o1235" == P && (d = l + n.shift(), c = u + n.shift(), p = d + n.shift(), v = c + n.shift(), b = p + n.shift(), _ = v + n.shift(), g = b + n.shift(), U = _ + n.shift(), m = g + n.shift(), S = U + n.shift(), l = m + n.shift(), u = S + n.shift(), n.shift(), z.U.P.curveTo(a, d, c, p, v, b, _), z.U.P.curveTo(a, g, U, m, S, l, u)), "o1236" == P && (d = l + n.shift(), c = u + n.shift(), p = d + n.shift(), U = _ = v = c + n.shift(), m = (g = (b = p + n.shift()) + n.shift()) + n.shift(), S = U + n.shift(), l = m + n.shift(), z.U.P.curveTo(a, d, c, p, v, b, _), z.U.P.curveTo(a, g, U, m, S, l, u)), "o1237" == P && (d = l + n.shift(), c = u + n.shift(), p = d + n.shift(), v = c + n.shift(), b = p + n.shift(), _ = v + n.shift(), g = b + n.shift(), U = _ + n.shift(), m = g + n.shift(), S = U + n.shift(), Math.abs(m - l) > Math.abs(S - u) ? l = m + n.shift() : u = S + n.shift(), z.U.P.curveTo(a, d, c, p, v, b, _), z.U.P.curveTo(a, g, U, m, S, l, u));
                    else if ("o14" == P) 0 < n.length && !i && (s = n.shift() + e.nominalWidthX, i = !0), 4 == n.length && (x = n.shift(), F = n.shift(), C = n.shift(), I = n.shift(), C = z.CFF.glyphBySE(e, C), I = z.CFF.glyphBySE(e, I), z.U._drawCFF(e.CharStrings[C], t, e, a), t.x = x, t.y = F, z.U._drawCFF(e.CharStrings[I], t, e, a)), h && (z.U.P.closePath(a), h = !1);
                    else if ("o19" == P || "o20" == P) n.length % 2 != 0 && !i && (s = n.shift() + e.Private.nominalWidthX), o += n.length >> 1, i = !(n.length = 0), f += o + 7 >> 3;
                    else if ("o21" == P) 2 < n.length && !i && (s = n.shift() + e.Private.nominalWidthX, i = !0), u += n.pop(), l += n.pop(), h && z.U.P.closePath(a), z.U.P.moveTo(a, l, u), h = !0;
                    else if ("o22" == P) 1 < n.length && !i && (s = n.shift() + e.Private.nominalWidthX, i = !0), l += n.pop(), h && z.U.P.closePath(a), z.U.P.moveTo(a, l, u), h = !0;
                    else if ("o25" == P) {
                        for (; 6 < n.length;) l += n.shift(), u += n.shift(), z.U.P.lineTo(a, l, u);
                        d = l + n.shift(), c = u + n.shift(), p = d + n.shift(), v = c + n.shift(), l = p + n.shift(), u = v + n.shift(), z.U.P.curveTo(a, d, c, p, v, l, u)
                    } else if ("o26" == P)
                        for (n.length % 2 && (l += n.shift()); 0 < n.length;) d = l, c = u + n.shift(), l = p = d + n.shift(), u = (v = c + n.shift()) + n.shift(), z.U.P.curveTo(a, d, c, p, v, l, u);
                    else if ("o27" == P)
                        for (n.length % 2 && (u += n.shift()); 0 < n.length;) c = u, p = (d = l + n.shift()) + n.shift(), v = c + n.shift(), l = p + n.shift(), z.U.P.curveTo(a, d, c, p, u = v, l, u);
                    else if ("o10" == P || "o29" == P) {
                        var I = "o10" == P ? e.Private : e;
                        0 == n.length ? console.log("error: empty stack") : (A = n.pop(), A = I.Subrs[A + I.Bias], t.x = l, t.y = u, t.nStems = o, t.haveWidth = i, t.width = s, t.open = h, z.U._drawCFF(A, t, e, a), l = t.x, u = t.y, o = t.nStems, i = t.haveWidth, s = t.width, h = t.open)
                    } else if ("o30" == P || "o31" == P) {
                        var A = n.length,
                            O = 0,
                            B = "o31" == P;
                        for (O += A - (T = -3 & A); O < T;) B = B ? (c = u, p = (d = l + n.shift()) + n.shift(), u = (v = c + n.shift()) + n.shift(), T - O == 5 ? (l = p + n.shift(), O++) : l = p, !1) : (d = l, c = u + n.shift(), p = d + n.shift(), v = c + n.shift(), l = p + n.shift(), T - O == 5 ? (u = v + n.shift(), O++) : u = v, !0), z.U.P.curveTo(a, d, c, p, v, l, u), O += 4
                    } else {
                        if ("o" == (P + "").charAt(0)) throw console.log("Unknown operation: " + P, r), P;
                        n.push(P)
                    }
                }
        }
        t.x = l, t.y = u, t.nStems = o, t.haveWidth = i, t.width = s, t.open = h
    };
    var U = z,
        m = /\r?\n/;

    function t(e) {
        function r(r) {
            var t = this;
            r = e.extend({
                src: ""
            }, r), this.src = r.src, this.font = null, this._hasLoaded = !1, this._loadCallbacks = [], e.FontList.push(this), this._fetchFontResource(this.src).then(function (r) {
                var t = U.parse(r);
                if (t.head && t.hmtx && t.hhea && t.glyf) return t;
                r = ["head", "hmtx", "hhea", "glyf"].filter(function (r) {
                    return !t[r]
                });
                throw new Error("Typr.js could not parse this font (unable to find " + r.join(", ") + ")")
            }).then(function (r) {
                t.font = r, t._hasLoaded = !0, t._loadCallbacks.forEach(function (r) {
                    return r()
                })
            }).catch(function (r) {
                throw new Error("Unable to load font from " + t.src + ":\n" + r)
            })
        }
        return r.prototype.waitForLoad = function () {
            var e = this;
            return new Promise(function (r, t) {
                e._hasLoaded && e._hasLoaded ? r() : e._loadCallbacks.push(r)
            })
        }, r.prototype.getFontScale = function (r) {
            return this._hasLoaded ? 1 / this.font.head.unitsPerEm * r : null
        }, r.prototype.measureText = function (r, t) {
            var e = this;
            if (void 0 === t && (t = 64), !this._hasLoaded) return null;
            var a = Array.isArray(r) ? r : r.split(m),
                n = this.font,
                o = n.hmtx.aWidth,
                i = this.getFontScale(t),
                s = n.hhea.descender,
                h = n.hhea.ascender,
                r = (n.hhea.lineGap, a.map(function (r) {
                    return U.U.stringToGlyphs(e.font, r).reduce(function (r, t) {
                        return -1 < t && t < o.length && (r += o[t]), r
                    }, 0)
                })),
                t = Math.max.apply(Math, r),
                n = 0 - s + h,
                a = n * a.length;
            return {
                width: t * i,
                height: a * i,
                lineHeight: n * i,
                lineWidths: r.map(function (r) {
                    return r * i
                }),
                descender: s * i,
                ascender: h * i
            }
        }, r.prototype.getTextPath = function (r, n, o, i, s, h, f) {
            var l = this;
            if (void 0 === n && (n = 64), void 0 === o && (o = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === h && (h = "left"), void 0 === f && (f = "bottom"), !this._hasLoaded) return [];
            var t = Array.isArray(r) ? r : r.split(m),
                u = this.measureText(r, n),
                d = u.lineWidths,
                c = u.lineHeight;
            return t.map(function (r, t) {
                var e = l.getTextOrigin(Object.assign({}, u, {
                        width: d[t]
                    }), o, i, s, h, f),
                    a = e[0],
                    t = e[1];
                e[2];
                i += c;
                r = U.U.stringToGlyphs(l.font, r), r = U.U.glyphsToPath(l.font, r);
                return l._convertPathCommands(r, n, a, t, s)
            }).flat()
        }, r.prototype.getTextGlyphs = function (r, o, i, s, h, f, l) {
            var u = this;
            if (void 0 === o && (o = 64), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === h && (h = 0), void 0 === f && (f = "left"), void 0 === l && (l = "bottom"), !this._hasLoaded) return [];
            var d = this.measureText(r, o),
                c = this.font.hmtx.aWidth,
                p = this.getFontScale(o),
                v = d.lineWidths,
                g = d.lineHeight;
            return (Array.isArray(r) ? r : r.split(m)).map(function (r, t) {
                var r = U.U.stringToGlyphs(u.font, r),
                    t = u.getTextOrigin(Object.assign({}, d, {
                        width: v[t]
                    }), i, s, h, f, l),
                    e = t[0],
                    a = t[1],
                    n = t[2];
                return s += g, r.filter(function (r) {
                    return -1 !== r
                }).map(function (r) {
                    var t = U.U.glyphToPath(u.font, r),
                        t = {
                            translate: {
                                x: e,
                                y: a,
                                z: n
                            },
                            path: u._convertPathCommands(t, o, 0, 0, 0)
                        };
                    return e += c[r] * p, t
                })
            }).flat()
        }, r.prototype.getTextOrigin = function (r, t, e, a, n, o) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === a && (a = 0), void 0 === o && (o = "bottom");
            var i = r.width,
                s = r.height,
                h = r.lineHeight;
            switch (n = void 0 === n ? "left" : n) {
                case "right":
                    t -= i;
                    break;
                case "center":
                    t -= i / 2
            }
            switch (o) {
                case "middle":
                    e -= s / 2 - h;
                    break;
                case "bottom":
                default:
                    e -= s - h
            }
            return [t, e, a]
        }, r.prototype._convertPathCommands = function (r, t, e, a, n) {
            void 0 === e && (e = 0), void 0 === a && (a = 0), void 0 === n && (n = 0);
            var o = this.getFontScale(t),
                t = r.cmds,
                i = r.crds.map(function (r) {
                    return r * o
                }),
                s = null,
                h = 0;
            return t.map(function (r) {
                var t = null;
                switch (s = s || {
                    x: e + +i[h],
                    y: a + -1 * i[h + 1],
                    z: n
                }, r) {
                    case "M":
                        return t = {
                            move: {
                                x: e + +i[h],
                                y: a + -1 * i[h + 1],
                                z: n
                            }
                        }, h += 2, t;
                    case "L":
                        return t = {
                            line: {
                                x: e + +i[h],
                                y: a + -1 * i[h + 1],
                                z: n
                            }
                        }, h += 2, t;
                    case "C":
                        return t = {
                            bezier: [{
                                x: e + +i[h],
                                y: a + -1 * i[h + 1],
                                z: n
                            }, {
                                x: e + +i[h + 2],
                                y: a + -1 * i[h + 3],
                                z: n
                            }, {
                                x: e + +i[h + 4],
                                y: a + -1 * i[h + 5],
                                z: n
                            }]
                        }, h += 6, t;
                    case "Q":
                        return t = {
                            arc: [{
                                x: e + +i[h],
                                y: a + -1 * i[h + 1],
                                z: n
                            }, {
                                x: e + +i[h + 2],
                                y: a + -1 * i[h + 3],
                                z: n
                            }]
                        }, h += 4, t;
                    case "Z":
                        return s && (t = {
                            line: s
                        }, s = null), t;
                    default:
                        return t
                }
            }).filter(function (r) {
                return null !== r
            })
        }, r.prototype._fetchFontResource = function (r) {
            return new Promise(function (t, e) {
                var a = new XMLHttpRequest;
                a.responseType = "arraybuffer", a.open("GET", r, !0), a.onreadystatechange = function (r) {
                    4 === a.readyState && (200 <= a.status && a.status < 300 ? t(a.response) : e("HTTP error " + a.status + ": " + a.statusText))
                }, a.send(null)
            })
        }, e.Font = r, e
    }

    function e(s) {
        var r = function (i) {
            function r(r) {
                var t = (r = s.extend({
                        font: null,
                        value: "",
                        fontSize: 64,
                        textAlign: "left",
                        textBaseline: "bottom"
                    }, r)).font,
                    e = r.value,
                    a = r.fontSize,
                    n = r.textAlign,
                    o = r.textBaseline,
                    r = function (r, t) {
                        var e, a = {};
                        for (e in r) Object.prototype.hasOwnProperty.call(r, e) && -1 === t.indexOf(e) && (a[e] = r[e]);
                        return a
                    }(r, ["font", "value", "fontSize", "textAlign", "textBaseline"]);
                i.call(this, Object.assign({}, r, {
                    closed: !0,
                    visible: !1,
                    path: [{}]
                })), this._font = null, this._value = e, this._fontSize = a, this._textAlign = n, this._textBaseline = o, this.font = t
            }
            i && (r.__proto__ = i);
            var t = {
                font: {
                    configurable: !0
                },
                value: {
                    configurable: !0
                },
                fontSize: {
                    configurable: !0
                },
                textAlign: {
                    configurable: !0
                },
                textBaseline: {
                    configurable: !0
                }
            };
            return ((r.prototype = Object.create(i && i.prototype)).constructor = r).prototype.updateText = function () {
                var r = this.font.getTextPath(this.value, this.fontSize, 0, 0, 0, this.textAlign, this.textBaseline);
                0 == r.length ? (this.path = [{}], this.visible = !1) : (this.path = r, this.visible = !0), this.updatePath()
            }, t.font.set = function (r) {
                var t = this;
                this._font = r, this.font.waitForLoad().then(function () {
                    t.updateText(), t.visible = !0;
                    for (var r = t.addTo; void 0 !== r.addTo;) r = r.addTo;
                    r && "function" == typeof r.updateRenderGraph && r.updateRenderGraph()
                })
            }, t.font.get = function () {
                return this._font
            }, t.value.set = function (r) {
                this._value = r, this.updateText()
            }, t.value.get = function () {
                return this._value
            }, t.fontSize.set = function (r) {
                this._fontSize = r, this.updateText()
            }, t.fontSize.get = function () {
                return this._fontSize
            }, t.textAlign.set = function (r) {
                this._textAlign = r, this.updateText()
            }, t.textAlign.get = function () {
                return this._textAlign
            }, t.textBaseline.set = function (r) {
                this._textBaseline = r, this.updateText()
            }, t.textBaseline.get = function () {
                return this._textBaseline
            }, Object.defineProperties(r.prototype, t), r
        }(s.Shape);
        return r.optionKeys = r.optionKeys.concat(["font", "fontSize", "value", "textAlign", "textBaseline"]), s.Text = r, s
    }

    function a(l) {
        var r = function (f) {
            function r(r) {
                var t = (r = l.extend({
                        font: null,
                        value: "",
                        fontSize: 64,
                        textAlign: "left",
                        textBaseline: "bottom",
                        color: "#333",
                        fill: !1,
                        stroke: 1
                    }, r)).font,
                    e = r.value,
                    a = r.fontSize,
                    n = r.textAlign,
                    o = r.textBaseline,
                    i = r.color,
                    s = r.fill,
                    h = r.stroke,
                    r = function (r, t) {
                        var e, a = {};
                        for (e in r) Object.prototype.hasOwnProperty.call(r, e) && -1 === t.indexOf(e) && (a[e] = r[e]);
                        return a
                    }(r, ["font", "value", "fontSize", "textAlign", "textBaseline", "color", "fill", "stroke"]);
                f.call(this, Object.assign({}, r, {
                    visible: !1
                })), this._font = null, this._value = e, this._fontSize = a, this._textAlign = n, this._textBaseline = o, this._color = i, this._fill = s, this._stroke = h, this.font = t
            }
            f && (r.__proto__ = f);
            var t = {
                font: {
                    configurable: !0
                },
                value: {
                    configurable: !0
                },
                fontSize: {
                    configurable: !0
                },
                textAlign: {
                    configurable: !0
                },
                textBaseline: {
                    configurable: !0
                },
                color: {
                    configurable: !0
                },
                fill: {
                    configurable: !0
                },
                stroke: {
                    configurable: !0
                }
            };
            return ((r.prototype = Object.create(f && f.prototype)).constructor = r).prototype.updateText = function () {
                for (var t = this; 0 < this.children.length;) this.removeChild(this.children[0]);
                this.font.getTextGlyphs(this.value, this.fontSize, 0, 0, 0, this.textAlign, this.textBaseline).filter(function (r) {
                    return 0 < r.path.length
                }).forEach(function (r) {
                    t.addChild(new l.Shape({
                        translate: r.translate,
                        path: r.path,
                        color: t.color,
                        fill: t.fill,
                        stroke: t.stroke,
                        closed: !0
                    }))
                }), this.updateFlatGraph()
            }, t.font.set = function (r) {
                var t = this;
                this._font = r, this._font.waitForLoad().then(function () {
                    t.updateText(), t.visible = !0;
                    for (var r = t.addTo; void 0 !== r.addTo;) r = r.addTo;
                    r && "function" == typeof r.updateRenderGraph && r.updateRenderGraph()
                })
            }, t.font.get = function () {
                return this._font
            }, t.value.set = function (r) {
                this._value = r, this.updateText()
            }, t.value.get = function () {
                return this._value
            }, t.fontSize.set = function (r) {
                this._fontSize = r, this.updateText()
            }, t.fontSize.get = function () {
                return this._fontSize
            }, t.textAlign.set = function (r) {
                this._textAlign = r, this.updateText()
            }, t.textAlign.get = function () {
                return this._textAlign
            }, t.textBaseline.set = function (r) {
                this._textBaseline = r, this.updateText()
            }, t.textBaseline.get = function () {
                return this._textBaseline
            }, t.color.set = function (t) {
                this._color = t, this.children.forEach(function (r) {
                    return r.color = t
                })
            }, t.color.get = function () {
                return this._color
            }, t.fill.set = function (t) {
                this._fill = t, this.children.forEach(function (r) {
                    return r.fill = t
                })
            }, t.fill.get = function () {
                return this._fill
            }, t.stroke.set = function (t) {
                this._stroke = t, this.children.forEach(function (r) {
                    return r.stroke = t
                })
            }, t.stroke.get = function () {
                return this._stroke
            }, Object.defineProperties(r.prototype, t), r
        }(l.Group);
        return r.optionKeys = r.optionKeys.concat(["color", "fill", "stroke", "font", "fontSize", "value", "textAlign", "textBaseline"]), l.TextGroup = r, l
    }
    return {
        init: function (r) {
            return r.FontList = [], r.waitForFonts = function () {
                return Promise.all(r.FontList.map(function (r) {
                    return r.waitForLoad()
                }))
            }, t(r), e(r), a(r), r
        },
        version: "1.2.8"
    }
});
//# sourceMappingURL=zfont.min.js.map